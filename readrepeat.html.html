<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>é€å¥æœ—è¯» + è·Ÿè¯»è®­ç»ƒ</title>
  <style>
    :root {
      --bg: #0b1020;
      --card: #121832;
      --muted: #8ea4c8;
      --text: #e7ecf6;
      --acc: #5b8cff;
      --acc-2: #17c964;
      --warn: #ffb020;
      --danger: #ff5d5d;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Noto Sans CJK SC", "Microsoft YaHei", Arial, sans-serif; background: radial-gradient(1200px 600px at 20% -10%, #1a2345, #0b1020); color: var(--text); }
    .container { max-width: 1200px; margin: 32px auto; padding: 0 16px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom: 16px; }
    header h1 { font-size: clamp(18px, 2.2vw, 28px); margin: 0; letter-spacing: 0.5px; }

    .grid { display: grid; grid-template-columns: 1.2fr .8fr; gap: 18px; }
    .card { background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)); border: 1px solid rgba(255,255,255,.08); box-shadow: var(--shadow); border-radius: var(--radius); }
    .card-header { display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,.06); }
    .card-header h2 { margin:0; font-size: 14px; font-weight:600; color: var(--muted); letter-spacing: .3px; text-transform: uppercase; }
    .card-body { padding: 14px; }

    textarea, select, input[type="text"] { width: 100%; background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.12); color: var(--text); border-radius: 12px; padding: 12px 14px; outline: none; transition: border-color .2s ease, box-shadow .2s ease; }
    textarea::placeholder { color: #93a7c8aa; }
    textarea:focus, select:focus, input[type="text"]:focus { border-color: var(--acc); box-shadow: 0 0 0 4px rgba(91,140,255,.15); }
    textarea { min-height: 280px; resize: vertical; line-height: 1.5; }

    .row { display:flex; align-items:center; gap: 10px; flex-wrap: wrap; }
    .muted { color: var(--muted); font-size: 12px; }

    .btn { appearance:none; border: none; border-radius: 999px; padding: 10px 16px; font-weight: 600; color: white; cursor: pointer; transition: transform .08s ease, filter .2s ease, box-shadow .2s ease; box-shadow: var(--shadow); background: linear-gradient(180deg, #6b93ff, #4a6fff); }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { background: linear-gradient(180deg, #2c335a, #1f2442); color: #d9e1ff; }
    .btn.success { background: linear-gradient(180deg, #26d07c, #13b065); }
    .btn.warn { background: linear-gradient(180deg, #ffc857, #ff9c2f); }
    .btn.danger { background: linear-gradient(180deg, #ff7878, #f04747); }

    .controls { display:flex; align-items:center; gap:10px; flex-wrap: wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.1); font-size: 12px; color: var(--muted); }

    .status { display:flex; align-items:center; gap:8px; font-size: 12px; color: var(--muted); }
    .dot { width:10px; height:10px; border-radius:50%; background:#64748b; box-shadow: 0 0 0 4px rgba(100,116,139,.12); }
    .dot.speaking { background: var(--acc); }
    .dot.listening { background: var(--acc-2); }
    .dot.idle { background: #64748b; }

    .current { font-size: 16px; line-height: 1.6; padding: 12px 14px; background: rgba(91,140,255,.08); border: 1px solid rgba(91,140,255,.25); border-radius: 12px; }

    /* Modal */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.5); display: none; align-items: center; justify-content: center; z-index: 50; }
    .modal { width: min(520px, 96vw); background: var(--card); border: 1px solid rgba(255,255,255,.09); border-radius: 18px; box-shadow: var(--shadow); overflow: hidden; }
    .modal header { padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,.06); }
    .modal header h3 { margin:0; font-size: 16px; }
    .modal .content { padding: 16px; }
    .modal .actions { display:flex; gap:10px; justify-content:flex-end; padding: 12px 16px 16px; }

    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:8px; padding: 2px 6px; font-size: 12px; }
    .small { font-size: 12px; color: var(--muted); }

    @media (max-width: 900px){
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>é€å¥æœ—è¯» + è·Ÿè¯»è®­ç»ƒ <span class="small">(Edge/Chrome Â· Web Speech API)</span></h1>
      <div class="status" id="status"><span class="dot idle" id="statusDot"></span><span id="statusText">å°±ç»ª</span></div>
    </header>

    <div class="card">
      <div class="card-header">
        <h2>è®¾ç½® / æ§åˆ¶</h2>
        <div class="pill">æç¤ºï¼šæ¯è¡Œä¸€æ¡è‹±æ–‡å¥å­</div>
      </div>
      <div class="card-body">
        <div class="row" style="gap:12px; align-items:flex-end;">
          <div style="flex:2; min-width: 260px;">
            <label class="small">ç²˜è´´ä½ çš„è‹±æ–‡å¥å­ï¼ˆæ¯è¡Œä¸€å¥ï¼‰</label>
            <textarea id="inputText" placeholder="ä¾‹å¦‚:\nI have a dream.\nLearning by speaking is effective.\nThis is a shadow DOM example."></textarea>
          </div>
          <div style="flex:1; min-width: 220px;">
            <label class="small">é€‰æ‹©è‹±è¯­å‘éŸ³ï¼ˆVoiceï¼‰</label>
            <select id="voiceSelect"></select>
            <div class="row" style="margin-top:10px;">
              <button class="btn" id="startBtn">å¼€å§‹</button>
              <button class="btn secondary" id="pauseBtn">æš‚åœ</button>
              <button class="btn secondary" id="resumeBtn">ç»§ç»­</button>
              <button class="btn danger" id="stopBtn">åœæ­¢</button>
            </div>
            <div style="margin-top:10px;" class="small">å¿«æ·é”®ï¼š<span class="kbd">Enter</span> å¼€å§‹ / ä¸‹ä¸€å¥ï¼Œ<span class="kbd">Space</span> æš‚åœ/ç»§ç»­ï¼Œ<span class="kbd">Esc</span> åœæ­¢</div>
          </div>
        </div>
      </div>
    </div>

    <div class="grid" style="margin-top:18px;">
      <div class="card">
        <div class="card-header">
          <h2>è¿›è¡Œä¸­</h2>
          <div class="pill" id="progress">0 / 0</div>
        </div>
        <div class="card-body">
          <div class="current" id="currentSentence">å½“å‰æ²¡æœ‰å¥å­</div>
        </div>
      </div>
      <div class="card">
        <div class="card-header">
          <h2>æˆ‘çš„è·Ÿè¯»è¯†åˆ«ç»“æœ</h2>
          <div class="pill">Speech-to-Text</div>
        </div>
        <div class="card-body">
          <textarea id="recognizedText" placeholder="ä½ çš„è‹±è¯­è·Ÿè¯»è¯†åˆ«ç»“æœä¼šå‡ºç°åœ¨è¿™é‡Œ" readonly></textarea>
        </div>
      </div>
    </div>
  </div>

  <!-- æœ—è¯»å®Œæˆåçš„é€‰æ‹©å¼¹çª— -->
  <div class="modal-backdrop" id="choiceModal">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="choiceTitle">
      <header><h3 id="choiceTitle">è¿™ä¸ªå¥å­è¦æ€ä¹ˆç»§ç»­ï¼Ÿ</h3></header>
      <div class="content">
        <p id="modalSentence" style="margin:0 0 8px 0; font-weight:600;"></p>
        <p class="small" style="margin:0;">é€‰æ‹© <strong>å†å¬ä¸€é</strong> æ¥é‡å¤ç³»ç»Ÿæœ—è¯»ï¼›é€‰æ‹© <strong>è·Ÿè¯»</strong> è¿›å…¥è¯­éŸ³è¾“å…¥æ¨¡å¼ï¼Œæˆ‘ä»¬å°†æŠŠä½ çš„å‘éŸ³è½¬æˆæ–‡å­—å¹¶ä¸åŸå¥å¯¹æ¯”ã€‚</p>
      </div>
      <div class="actions">
        <button class="btn secondary" id="cancelModal">å–æ¶ˆ</button>
        <button class="btn warn" id="listenAgainBtn">å†å¬ä¸€é</button>
        <button class="btn success" id="shadowBtn">è·Ÿè¯»</button>
      </div>
    </div>
  </div>

  <!-- è·Ÿè¯»ä¸ä¸€è‡´æ—¶çš„å¤„ç†å¼¹çª— -->
  <div class="modal-backdrop" id="mismatchModal">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="mmTitle">
      <header><h3 id="mmTitle">å’ŒåŸå¥ä¸ä¸€è‡´ï¼Œä¸‹ä¸€æ­¥ï¼Ÿ</h3></header>
      <div class="content">
        <p style="margin:0 0 10px 0;">åŸå¥ï¼š</p>
        <div class="current" id="mmOriginal" style="margin-bottom:10px"></div>
        <p style="margin:0 0 10px 0;">ä½ çš„è¯†åˆ«ï¼š</p>
        <div class="current" id="mmRecognized"></div>
      </div>
      <div class="actions">
        <button class="btn warn" id="mmListenAgain">å†å¬ä¸€é</button>
        <button class="btn success" id="mmReadAgain">æˆ‘å†è¯»ä¸€é</button>
      </div>
    </div>
  </div>

  <script>
    // ---------- Utilities ----------
    const qs = (sel) => document.querySelector(sel);
    const qsa = (sel) => Array.from(document.querySelectorAll(sel));
    const statusDot = qs('#statusDot');
    const statusText = qs('#statusText');
    const setStatus = (mode, text) => {
      statusDot.className = 'dot ' + (mode || 'idle');
      statusText.textContent = text || 'å°±ç»ª';
    };

    const normalize = (s) => (s||'')
      .toLowerCase()
      .replace(/[^a-z'\s]/g, ' ') // ä¿ç•™è‹±æ–‡å’Œæ’‡å·
      .replace(/\s+/g, ' ')
      .trim();

    // ---------- TTS (SpeechSynthesis) ----------
    const synth = window.speechSynthesis;
    let voices = [];
    const voiceSelect = qs('#voiceSelect');

    function populateVoices() {
      voices = synth.getVoices().filter(v => /en/i.test(v.lang));
      voiceSelect.innerHTML = '';
      if (voices.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'ï¼ˆæœªæ£€æµ‹åˆ°è‹±è¯­è¯­éŸ³ï¼Œç¨åå†è¯•ï¼‰';
        voiceSelect.appendChild(opt);
        return;
      }
      voices.forEach((v, idx) => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI;
        opt.textContent = `${v.name} â€” ${v.lang}${v.default ? ' (é»˜è®¤)' : ''}`;
        if (v.default && voiceSelect.selectedIndex === -1) opt.selected = true;
        voiceSelect.appendChild(opt);
      });
      if (voiceSelect.selectedIndex === -1 && voices[0]) voiceSelect.value = voices[0].voiceURI;
    }

    populateVoices();
    if (typeof speechSynthesis !== 'undefined') {
      speechSynthesis.onvoiceschanged = () => {
        // æŸäº›æµè§ˆå™¨ä¼šå¤šæ¬¡è§¦å‘ï¼Œå»æŠ–
        const prev = voiceSelect.options.length;
        populateVoices();
        // è‹¥ä¹‹å‰å·²ç»é€‰æ‹©è¿‡ï¼Œå°½é‡ä¿æŒ
        if (prev && selectedVoiceURI && qsa('#voiceSelect option').some(o=>o.value===selectedVoiceURI)) {
          voiceSelect.value = selectedVoiceURI;
        }
      };
    }

    let utter; // å½“å‰ utterance
    let selectedVoiceURI = '';

    function speakSentence(text) {
      return new Promise((resolve, reject) => {
        if (!text) return resolve();
        if (synth.speaking) {
          try { synth.cancel(); } catch(e){}
        }
        utter = new SpeechSynthesisUtterance(text);
        selectedVoiceURI = voiceSelect.value;
        const v = voices.find(v => v.voiceURI === selectedVoiceURI) || voices[0];
        if (v) utter.voice = v;
        utter.rate = 1; // å¯æŒ‰éœ€æš´éœ²ç»™ UI
        utter.pitch = 1;
        utter.onstart = () => setStatus('speaking', 'æ­£åœ¨æœ—è¯»â€¦');
        utter.onend = () => { setStatus('idle', 'æœ—è¯»å®Œæˆ'); resolve(); };
        utter.onerror = (e) => { setStatus('idle', 'æœ—è¯»å‡ºé”™'); reject(e.error || e); };
        synth.speak(utter);
      });
    }

    function cancelSpeak(){ try { synth.cancel(); } catch(e){} }
    function pauseSpeak(){ try { synth.pause(); } catch(e){} }
    function resumeSpeak(){ try { synth.resume(); } catch(e){} }

    // ---------- STT (SpeechRecognition) ----------
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;

    function initRecognition(){
      if (!SpeechRecognition) return null;
      const rec = new SpeechRecognition();
      rec.lang = 'en-US';
      rec.interimResults = false;
      rec.continuous = false;
      rec.maxAlternatives = 1;
      return rec;
    }

    function listenOnce(){
      return new Promise((resolve, reject) => {
        if (!recognition) recognition = initRecognition();
        if (!recognition) {
          return reject(new Error('æ­¤æµè§ˆå™¨æš‚ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ï¼ˆSpeechRecognitionï¼‰ã€‚'));
        }
        setStatus('listening', 'æ­£åœ¨å¬ä½ è¯»â€¦');
        recognition.onresult = (ev) => {
          const text = ev.results[0][0].transcript || '';
          setStatus('idle', 'è¯†åˆ«å®Œæˆ');
          resolve(text);
        };
        recognition.onerror = (e) => {
          setStatus('idle', 'è¯†åˆ«å‡ºé”™');
          reject(e.error || e);
        };
        recognition.onend = () => {
          // è‹¥æœªè§¦å‘ resultï¼Œä»è¦å›åˆ° idle
          if (statusText.textContent.includes('å¬ä½ è¯»')) setStatus('idle', 'è¯†åˆ«ç»“æŸ');
        };
        try { recognition.start(); } catch (e) { reject(e); }
      });
    }

    // ---------- App State ----------
    const inputText = qs('#inputText');
    const currentSentenceEl = qs('#currentSentence');
    const recognizedTextEl = qs('#recognizedText');
    const progressEl = qs('#progress');
    const startBtn = qs('#startBtn');
    const pauseBtn = qs('#pauseBtn');
    const resumeBtn = qs('#resumeBtn');
    const stopBtn = qs('#stopBtn');

    let lines = [];
    let idx = -1;
    let running = false;

    function refreshProgress(){ progressEl.textContent = `${Math.max(0, idx)}/${lines.length}`; }

    function loadLines(){
      lines = inputText.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      idx = -1;
      refreshProgress();
    }

    function setCurrentSentence(text){
      currentSentenceEl.textContent = text || 'å½“å‰æ²¡æœ‰å¥å­';
    }

    // ---------- Modals ----------
    const choiceModal = qs('#choiceModal');
    const modalSentence = qs('#modalSentence');
    const cancelModal = qs('#cancelModal');
    const listenAgainBtn = qs('#listenAgainBtn');
    const shadowBtn = qs('#shadowBtn');

    const mismatchModal = qs('#mismatchModal');
    const mmOriginal = qs('#mmOriginal');
    const mmRecognized = qs('#mmRecognized');
    const mmListenAgain = qs('#mmListenAgain');
    const mmReadAgain = qs('#mmReadAgain');

    function openModal(el){ el.style.display = 'flex'; el.focus(); }
    function closeModal(el){ el.style.display = 'none'; }

    cancelModal.addEventListener('click', ()=> closeModal(choiceModal));

    // ---------- Main flow ----------
    async function startFlow(){
      loadLines();
      if (!lines.length) { alert('è¯·å…ˆç²˜è´´è‹±æ–‡å¥å­ï¼ˆæ¯è¡Œä¸€å¥ï¼‰'); return; }
      running = true;
      await nextSentence();
    }

    async function nextSentence(){
      if (!running) return;
      idx++;
      refreshProgress();
      if (idx >= lines.length) {
        setCurrentSentence('å…¨éƒ¨å®Œæˆ ğŸ‰');
        return;
      }
      const sentence = lines[idx];
      setCurrentSentence(sentence);
      await speakSentence(sentence);
      modalSentence.textContent = sentence;
      openModal(choiceModal);
    }

    async function handleListenAgain(){
      closeModal(choiceModal);
      await speakSentence(lines[idx]);
      // æœ—è¯»ç»“æŸåå†æ¬¡ç»™å‡ºé€‰æ‹©
      modalSentence.textContent = lines[idx];
      openModal(choiceModal);
    }

    async function handleShadowing(){
      closeModal(choiceModal);
      try {
        const heard = await listenOnce();
        recognizedTextEl.value = heard;
        const same = normalize(heard) === normalize(lines[idx]);
        if (same) {
          await speakFeedback('Great! Moving to the next sentence.');
          await nextSentence();
        } else {
          // ä¸ä¸€è‡´ï¼Œå¼¹å‡ºå¤„ç†å¯¹è¯æ¡†
          mmOriginal.textContent = lines[idx];
          mmRecognized.textContent = heard || 'ï¼ˆç©ºç»“æœï¼‰';
          openModal(mismatchModal);
        }
      } catch (e) {
        alert('è¯†åˆ«å¤±è´¥ï¼š' + (e && e.message ? e.message : e));
      }
    }

    async function speakFeedback(text){
      try { await speakSentence(text); } catch(e){}
    }

    async function handleMismatchListen(){
      closeModal(mismatchModal);
      await speakSentence(lines[idx]);
      // å†æ¬¡ç»™å‡ºé€‰æ‹©
      modalSentence.textContent = lines[idx];
      openModal(choiceModal);
    }

    async function handleMismatchRead(){
      closeModal(mismatchModal);
      try {
        const heard = await listenOnce();
        recognizedTextEl.value = heard;
        const same = normalize(heard) === normalize(lines[idx]);
        if (same) {
          await speakFeedback('Nice! Next sentence.');
          await nextSentence();
        } else {
          // ä»ä¸ä¸€è‡´ï¼Œç»§ç»­è®©ç”¨æˆ·é€‰æ‹©
          mmOriginal.textContent = lines[idx];
          mmRecognized.textContent = heard || 'ï¼ˆç©ºç»“æœï¼‰';
          openModal(mismatchModal);
        }
      } catch (e) {
        alert('è¯†åˆ«å¤±è´¥ï¼š' + (e && e.message ? e.message : e));
      }
    }

    // ---------- Controls ----------
    startBtn.addEventListener('click', startFlow);
    pauseBtn.addEventListener('click', () => { pauseSpeak(); setStatus('idle', 'å·²æš‚åœ'); });
    resumeBtn.addEventListener('click', () => { resumeSpeak(); setStatus('speaking', 'ç»§ç»­æœ—è¯»â€¦'); });
    stopBtn.addEventListener('click', () => { running = false; cancelSpeak(); setStatus('idle', 'å·²åœæ­¢'); });

    listenAgainBtn.addEventListener('click', handleListenAgain);
    shadowBtn.addEventListener('click', handleShadowing);

    mmListenAgain.addEventListener('click', handleMismatchListen);
    mmReadAgain.addEventListener('click', handleMismatchRead);

    // é”®ç›˜å¿«æ·é”®
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); if (!running) startFlow(); else nextSentence(); }
      if (e.code === 'Space') { e.preventDefault(); if (synth.paused) resumeSpeak(); else pauseSpeak(); }
      if (e.key === 'Escape') { running = false; cancelSpeak(); }
    });

    // åˆå§‹æç¤ºï¼šæ£€æµ‹è¯†åˆ«å¯ç”¨æ€§
    window.addEventListener('load', () => {
      if (!SpeechRecognition) {
        const msg = 'æç¤ºï¼šæ­¤æµè§ˆå™¨æš‚ä¸æ”¯æŒ SpeechRecognitionï¼ˆè¯­éŸ³è¯†åˆ«ï¼‰ã€‚åœ¨ Edge/Chrome æœ€æ–°ç‰ˆä¸€èˆ¬å¯ç”¨ï¼Œæˆ–éœ€è¦åœ¨è®¾ç½®ä¸­å¼€å¯ç›¸å…³æƒé™ã€‚';
        console.warn(msg);
      }
    });
  </script>
</body>
</html>
